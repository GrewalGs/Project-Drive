#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  X2Encoder,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  Y1Encoder,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  X1Encoder,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           X1,            tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           X2,            tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           Y1,            tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           Y2,            tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

	float XCM = 370;
	float YCM = 370;
	float X = XCM * 14;
	float Y = YCM * 14;
	int Speed = 127;
	float param = X/Y;
	float angle = atan(param)*180/3.1415;
	float degrees10 = angle*10;
	float dist = sqrt((X*X)+(Y*Y));
	int error = 30;

task main()
{
	//Calibrate Gyro// set gyro to 0
	SensorType[in1] = sensorNone;
  wait1Msec(1000);
  SensorType[in1] = sensorGyro;
  wait1Msec(1000);

  //Set encoder velue to 0 / reset encoders
  SensorValue[X1Encoder] = 0;
	SensorValue[X2Encoder] = 0;
	SensorValue[Y1Encoder] = 0;



	 //While the absolute value of the gyro is less than the desired rotation - 100...
  while(abs(SensorValue[in1]) < degrees10 - 100)
  {
    motor[X1] = 40;
    motor[X2] = -40;
  }
  //Brief brake to eliminate some drift
  motor[X1] = -5;
  motor[X2] = 5;
  wait1Msec(100);

  //Second while loop to move the robot more slowly to its goal, also setting up a range
  //for the amount of acceptable error in the system
  while(abs(SensorValue[in1]) > degrees10 + error || abs(SensorValue[in1]) < degrees10 - error)
  {
    if(abs(SensorValue[in1]) > degrees10)
    {
      motor[X1] = -30;
      motor[X2] = 30;
    }
    else
    {
      motor[X1] = 30;
      motor[X2] = -30;
    }
  }
  //Stop
  motor[X1] = 0;
  motor[X2] = 0;
  wait1Msec(250);


	while(abs(SensorValue[Gyro]) < ((angle*10)-(angle*2)))
  {
    motor[X1] = 40;
    motor[X2] = -40;
  }
  motor[X1] = -5;
  motor[X2] = 5;

  while(SensorValue[Y1Encoder] < dist)
	{
		motor[Y1] = -speed;
		motor[Y2] = -speed;
	}
		motor[Y1] = 0;
		motor[Y2] = 0;
}
